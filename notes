Java extension is .java
if we need to print something we need method in java. Here print is a method.Use colon after every statement
System.out.println("Hello World");
bytecode has extension .class

---WORA
Java is a Write Once Run Anywhere.once we write code in our machine it can be run in any machine having the jre and jvm

---JVM
for running java we need jvm java virtual machine irrespective of the os ios windows etc.no jvm means we cant run.We have os on hardware. JVM execute java code we create.JVm undestands only byte code which is not readable by humans.so we neeed a compiler to convert the java code we write to a bytecode.Our code can be many files. out of all these files if we have to run first file then the first file need to have main method.Exexution start from the file we specify which has the main.

---JRE
jvm alone is not enough to run a java program.we need a lot of libraries also...jvm along with libraries gives jre or java runtime environment.

---JDK
stands for java development kit.Jdk will have jre and jre will have jvm.Developersv install jdk.

---MAIN
main comes with public static void main(arguments).
Also we need to have a class.Main should come inside the class.In java we cfeate everything as class and objects.
eg:
public class javatutorial
{
    public static void main(String a[])
    {
        System.out.println("Hello world");
    }
}
---println
when we use println after printing the statement the cursoor move to next line...if we use print cursor stays there itself so next statement also will be printed in the same line


---DATATYPES
boolean    boolean b =true;                 true and false..used for conditions
char    char c = 'k';     use single quotes..accepts only single alphabet or single digit number ..'5'
int                       negative and positive numbers
short
byte                      -128 to 127
long        long num = 5643l    put l after the number
float       float num = 5.6f   -we have to explicitly mention it
double      double num = 5.6    more precision

int num1=4;
datatype first then variable name

public class javatutorial
{
    public static void main(String a[])
    {
        int num1=9;
        int num2=1;
        int result= num1+num2;
        System.out.println(result);
      
    }
}

---LITERALS
literals are fixed values that are used directly in the code to represent data.
Integer Literals: Whole numbers, written in decimal, hexadecimal (e.g., 0x1A), octal (e.g., 012), or binary (e.g., 0b101).
Floating-Point Literals: Real numbers, written as decimals or in scientific notation (e.g., 3.14, 1.23e4).
Character Literals: Single characters enclosed in single quotes (e.g., 'A', '1').
String Literals: Sequences of characters enclosed in double quotes (e.g., "Hello, World!").
Boolean Literals: Represent true or false.
Null Literal: Represents a null reference, indicating the absence of an object.

---IMPLCIT CONVERSION(TYPE CONVERSION)
Suppose we have byte b = 126 and int a = 256...we know that byte can only store upto 127 ...when we assign b=a ..it cant but we can assign a=b;
a=b assignment is called implicit type conversion

---EXPLICIT TYPE CONVERSION(CASTING)
WE NEED TO CHANGE THE DATATYPE TO ACCOMODATE THEM
eg:
public class javatutorial
{
    public static void main(String a[])
    {
        byte num1=126;
        int num2=257;
        num1= (byte)num2;
        System.out.println(num1);

    }
}

while converting int to byte modulus is taken. means the remainder after dividing 257 with 256 is done ...means output will be 1.

another example 

float f=5.6f;
int x= (int)f;                     Output :5
this works.

---TYPE PROMOTION
EG:
byte b=10;
byte c=30;
int result = b*c;
Here after multiplication the result is 300.even it was the result of multiplication of bytes it is out of range...so store them in int.

---ARITHMETIC OPERATORS
addition +
substraction -
multiplication *
division /            give quotient only
modulus %             give reminder
post increment num++
pre increment  ++num
postdecrement num--
pre decrement --num


eg:
int num1 = 7;
int result= num1 +1;
System.out.println(result);                           output:8

eg:
int num1 = 7;
num1++;
System.out.println(num1);                            output:8


eg:
num--;

---RELATIONAL OPERATORS
less than       <
greater than    >
equal to        =       assignment operator
comparison      ==
not equal       !=
                >=
                <=

---LOGICAL OPERATORS
and        &
or         |
not       !
short circuit and    &&
short circuit or     ||

eg:
r= x>y && a<b
If first one is false then it won't look the second thing.similarly for || also.if first one is true it immediately give the output true.
eg:
s= !r
if r is true s is false
eg:
public class javatutorial
{
    public static void main(String a[])
    {
        int c=2;
        int b=3;
        boolean result= c>b;
        System.out.println(result);

    }
}
output is false.

---CONDITIONAL STATEMENTS

----IF ELSE

eg:
public class javatutorial
{
    public static void main(String a[])
    {
        int c=2;
        //int b=3;
       if(c>7)
        System.out.println("Hello");
       else
           System.out.println("bye");

    }
}

eg:
public class javatutorial
{
    public static void main(String a[])
    {
        int c=2;
        //int b=3;
       if(c>7)
       {
        System.out.println("Hello");                   ----if multiple statements then use bracket
        System.out.println("thank");
        }
       else
           System.out.println("bye");

    }
}

---IF ELSE IF
EG:
public class javatutorial
{
    public static void main(String a[])
    {
        int c=2;
        int b=3;
       if(c>7)
        System.out.println("Hello");                    
       else if(condition)
           System.out.println("bye");
       else
           System.out.println("bye");
    }
}

---TERNARY OPERATOR/CONDITIONAL OPERATOR

public class javatutorial
{
    public static void main(String a[])
    {
        int c=2;
        int result;
        result=c>3? 10:20;
            System.out.println(result);                   


    }
}

---SWITCH STATEMENT

public class javatutorial
{
    public static void main(String a[])
    {
        int n=3;
        switch(n)
        {
            case 1:
                System.out.println("monday");
                break;
            case 2:
                System.out.println("tuesday");
                break;
            case 3:
                System.out.println("wednesday");
                break;

        }
    }
}

OUTPUT: WEDNESDAY

eg:
new switch statement allows to use string also as cases.earlier it was only numbers.if not any of the cases then it executes default
public class javatutorial
{
    public static void main(String a[])
    {
        String day="friday";
        switch(day)
        {
            case "monday","tuesday":
                System.out.println("6am");
                break;
            case "wednesday":
                System.out.println("7am");
                break;
            default:
                System.out.println("8am");
                break;

        }
    }
}

----WHILE LOOP
public class javatutorial
{
    public static void main(String a[])
    {
        int i=1;
        while(i<5) {
            System.out.println("result");
            i++;
        }
    }
}

suppose for every result we have to print hi 3 times
public class javatutorial
{
    public static void main(String a[])
    {
        int i=1;
        while(i<5) {
            System.out.println("result");
            int j = 1;
            while (j <= 3) {
                System.out.println("hi");
                j++;
            }
            i++;
        }
    }
}

----DO WHILE LOOP

eg:
public class javatutorial
{
    public static void main(String a[])
    {
        int i=1;
        do{
            System.out.println("result");
            i++;
           }while(i<3);
    }
}

----FOR LOOP

public class javatutorial
{
    public static void main(String a[])
    {
        int i;
        for(i=0;i<=4;i++)
        {
            System.out.println("result");

        }
    }
}


---CLASS AND OBJECT THEORY IN JAVA

in java everything around is considered as an object.Class is like a blueprint.We create objects using that.Objects differ each other.Object will have a property and behaviour.human sare objects and has property like know how to dance walk etc...also everyone walk differently thats the behaviour. Carpenter creates a table(object) we need to give the blueprint or design specs to him...so as it is technical we give the details to a person and he explains technically to the carpenter .similarly we create a class file in programming that act as a bleprint for the carpenter to create the object.we create a classfile it is converted to byte code after compilation then goes to jvm and then get object.
- inside class we write variables(properties)and write methods(functions).
-then we create another class to create objects using keyword new.
-then values are assigned to variables
-we can call the function also if  it is already created in the class

---METHODS/FUNCTIONS
methods start with how we can access them,public means we can access them anywhere.after a method perform operations we have to specify the result and also along with its datatype.
public int add          for a calculator


eg:
class Sample {
    int a;                   
    int b;
                               //initialised two variables a and b, also defined a function display which displays the value of a.
    void display()
    {
        System.out.println(a);
    }
}
class Hello {
    public static void main(String[] ar) {
        Sample s1 = new Sample();                       //created two objects s1 and s2.
        Sample s2 = new Sample();
        s1.a = 10;                                         // assigned values to the variables of that particular object
        s1.b = 20;
        s2.a = 30;
        s2.b = 40;
        s1.display();                     //displaying value of a of object s1
        System.out.println(s1.a);         //printing value of a of object s1


    }
}

OUTPUT:

eg:
class Sample {
    int a;
    int b;

    void sum()                                   //void used when we dont expect any value in return..just printing only..if we use  public int sum() then use                                                          return inside it for returning some values 
    {
        System.out.println(a+b);
    }
    void difference()
    {
        System.out.println(a-b);
    }
}
class Hello {
    public static void main(String hey[]) {                //string ar is not necessary..we can give any name..
        Sample s1 = new Sample();
        Sample s2 = new Sample();
        s1.a = 10;
        s1.b = 20;
        s2.a = 30;
        s2.b = 40;
        s1.sum();
        s2.difference();
    }
}

----METHOD OVERLOADING
means we have many methods with the same name but the parameters are different.

class Calculator
{
    int num;                                   //instance variable
    public int add(int a,int b)               // a,b local variable
    {
        int result = a+b;
        return result;
    }
    public int add(int a,int b,int c)            //two add methods but different parameters
    {
        int result = a+b+c;
        return result;
    }
}

public class demo
{
    public static void main(String ar[])
    {
        Calculator obj =new Calculator();
        int res= obj.add(3,4,5);                  //goes with second add
        System.out.println(res);
    }
}

----STACK AND HEAP

In JVM we have stack and heap memory.
STACK:- arranged one above the other and follows first in first out algorithm.Every method will have one stack....main is also a method....so for the below example 2 methods and 2 stacks will be there(add and main)
***In stack data is stored as key and value ..key will be variable name and value will be variable value.
for table add the stack will be like these:
                                                                          101
ADD STACK                     MAIN STACK                                 HEAP
a   |  3                       r1 | 7                                   num=5
b   |  4                     data | 10                                   add()
                             obj1 | 101
Here num doesnt belong to any of the methods add or main..so its not inside any of the stacks.if we declare inside only we put it into stack.even methodinakath just num print chythal polum it wont be in stack..
Such INSTANCE VARIABLES go into HEAP.

***HEAP:-it is open space means expandable.
in the heap instance variable num is stored.also the method is stored without much defiinitions.heap also has an addresss say 101. this 101 is stored as value corresponding to obj1 in main stack....when obj1.a is called in the program then it looks the address 101 in heap it gets the add function from heap.there is a link btw stack and heap through this address.there can be multiple objects in heap

class Calculator
{   
    int num=5;                                //instance variable
    public int add(int a,int b)               //local variable
    {
        int result = a+b;
        return result;
    }
}

public class demo
{
    public static void main(String ar[])
    {
        int data =10;

        Calculator obj =new Calculator();
        int res= obj.add(3,4);
        System.out.println(res);
    }
}


-----ARRAY IN JAVA
int num[] ={3,4,5}

int num[] = new int[4]              //returns array with all 4 values as 0 {0,0,0,0}
to put values

num[0]=1;
num[1]=2;
.
.
.
eg:
public class demo {
    public static void main(String ar[])
    {
        int arr[]={3,4,5};
        System.out.println(arr[1]);
    }
}

to print all the values in an array

public class demo {
    public static void main(String ar[])
    {
        int arr[]={3,4,5};
        int i;

        for(i=0;i<3;i++)
        {
            System.out.println(arr[i]);

        }
    }
}


----MULTI DIMENSIONAL ARRAY
multiple arrays combined to get one big array

declaration:  int nums[][]=new int[3][4];               // 3 internal arrays (rows) and 4 elements each(coloums)

eg:
public class demo {
    public static void main(String ar[])
    {
        int i;
        int j;
        int nums[][]=new int[3][4];
        for(i=0;i<3;i++)
        {
            for (j=0;j<=3;j++) {
                System.out.print(nums[i][j] +" ");
            }
            System.out.println(" ");
        }
    }
}

OUTPUT:
0 0 0 0  
0 0 0 0                 //by default values for integer array willbe 0
0 0 0 0  

----JAGGED ARRAY
number of elements in an array is not specified.but how many arrays are there is specified.
int nums[][]=new int[3][]
for each row there will be specific size.

----DRAWBACKS OF ARRAY IN JAVA
*int nums[]=new int[4]     
this statement creates an instance variable.It is stored in heap and at that time itself it occupies 4 spaces in memory...so after this declaratiion we cant change its size.
*array cannot store int string all at a time..but collections can

-----ARRAY OBJECT
class Student
{
    String name;
    int marks;
}

public class demo {
    public static void main(String ar[])
    {
        Student s1 = new Student();
        s1.name="Ashly";
        s1.marks=96;
        Student s2 = new Student();
        s2.name="Maria";
        s2.marks=99;

        Student children[]= new Student[2];
        children[0]= s1;
        children[1]=s2;
        for(int i=0;i<children.length;i++)
            System.out.println(children[i].name + ":" + children[i].marks);


        }
    }

OUTPUT:
Ashly:96
Maria:99

We create Student class and create objects s1,s2,s3.Then we created array children ans assigned values s1,s2 and s3 to it.

----STRING IN JAVA
class Student
{
    String name;
    int marks;
}

public class demo {
    public static void main(String ar[])
    {
        String obj= new String("Ashly");
        System.out.println(obj);

        }
    }

**CONCATENATION is possible with strings
class Student
{
    String name;
    int marks;
}

public class demo {
    public static void main(String ar[])
    {
        String obj= new String("Ashly");
        System.out.println(obj);
        System.out.println(obj.concat("James"));
        }
    }

OUTPUT:
Ashly
AshlyJames

----JAVA STRINGS ARE IMMUTABLE
In Java, strings are immutable, meaning that once a String object is created, its value cannot be changed. 
eg:
String name= new String("Ashly");
String name=new String ("Maria");

when we give like this actually the value of object name ,Ashly is not replaced by Maria.Here is how it works.
*In the stack an object name is created and the address is given as 101 which is present in heap.
*In heap, there will be address 101 and the value corresponding it will be Ashly.(STRING CONSTANT POOL)
*When we assign the same object with Maria the same object points to another address 102 and in the heap corresponding to the address 102 "Maria is stored...so once created string cannot be changed.

String name= new String("Ashly");
String anothername=new String ("Ashly");
when we give like this two objects are not created in the stack
*it will check the string const. pool in heap and if Ashly is already there it will give the location to otherkey also.
*both keys name and anothername points to same address 101

----HOW CAN WE CREATE MUTABLE STRING?(STRING BUFFER)
*StringBuffer sb=new StringBuffer();
System.out.println(sb.capacity());    //OUTPUT:16

By using string buffer the capacity is 16 means it provide 16 spaces for a string for future expansion.

StringBuffer sb=new StringBuffer("Ashly");
System.out.println(sb.capacity());    //OUTPUT:21

capacity increased to 21.
*StringBuffer sb=new StringBuffer("Ashly");
sb.append(" James");
System.out.println(sb);                 //output:Ashly James we can append string using string buffer

* String str=sb.toString();
  System.out.println(str);          //we cannot assign a string buffer to a string...so we use tostring to convert it to string and then asssign it to str.

*we can delete a character at particular index
sb.deleteCharAt(2);
System.out.println(sb);

*we can insert striing at particular index
sb.insert(2,"and");
System.out.println(sb);                //output:Asandhly James

*we can extract substring by giving start and stop index
*we can set length of the string
*we can set minimum capacity using ensurecapacity()

----STATIC VARIABLE IN JAVA

class Phone
{
    String brand;
    int price;
    String name;
    public void display()
    {
        System.out.println(brand +":"+ price +":"+ name);
    }
}

public class demo {
    public static void main(String ar[])
    {
        Phone obj1=new Phone();
        Phone obj2=new Phone();
        obj1.brand="Apple";
        obj1.price=1500;
        obj1.name="Smartphone";
        obj2.brand="Samsung";
        obj2.price=1700;
        obj2.name="Smartphone";
        obj1.display();
        obj2.display();


        }
    }

OUTPUT:
Apple:1500:Smartphone
Samsung:1700:Smartphone
//Using static variable means if we make change to the value of that variable related to any one of the objects then auomatically it is applicable for all objects.It can be used for variables having same values.
*Here smart phone is common name so making that instance variable static .
eg:
class Phone
{
    String brand;
    int price;
    static String name;                       //made it static
    public void display()
    {
        System.out.println(brand +":"+ price +":"+ name);
    }
}

public class demo {
    public static void main(String ar[])
    {
        Phone obj1=new Phone();
        Phone obj2=new Phone();
        obj1.brand="Apple";
        obj1.price=1500;
        Phone.name="Smartphone";            //after making it static we have to refer it using class name not object name so use Phone
        obj2.brand="Samsung";
        obj2.price=1700;
        Phone.name="Smartphone";
        obj1.name="smart";                     //we changed obj1 only to smart but both objects value changes.
        obj1.display();
        obj2.display();                      
        }
    }
*OUTPUT:
Apple:1500:smart
Samsung:1700:smart


----STATIC METHOD
in front of the method/function there will be the keyword static.Usingstatic method we can call method anywhwere from the class also no need of creating the object.

eg:
for the above example
public void display()
    {
        System.out.println(brand +":"+ price +":"+ name);
    }
public static void show()                      //static method
    {
        System.out.println("in static method");
    }

if we use static method then we can call it directly using class name.
Phone.display();  ----- here display is not static method so it cannot be called using classname phone.returns no value.we need to create object of phone and the call.
Phone.show(); ---------show is a static method so it can be called using the class name.returns "in a static method"
*public class Demo{
 public static void main(string ar[])
if we dont use static in main method then we  have to create an object of demo to call it.ain is the start of execution of program.If execution is not started then we cant create an object of demo.it will be a dead lock

----ENCAPSULATION
Data is kept hidden for limited acccess by users.data is kept inside boxes .These boxes are variables.No one can see the data .if they want, they have to ask and we can decide whether to tell it or not. So use private keyword with instance variable.So we can access that only within that class.
eg:brain has all the info like our name age etc...it is kept private ...when someone asks age brain thinks whether i need to share or not.If yes brain can share it only by methods speaking writing etc...So public methods are defined inside the class to access these private variables.

class human
{
    private String name="Ashly";  //private keyword used to hide data
    private int age=23;

    public String getName()       //to access these data we need to use public method and have to specify the return datatype string int etc.
    {
         return name;
    }
    public  int getAge()
    {
        return age;
    }
}

public class demo {
    public static void main(String ar[])
    {
        human obj=new human();
        System.out.println(obj.getName() + obj.getAge());    //we have to access private variables using the publicc methods...obj.getName()...we wont get data                                                                                                                                                  using obj.name
        }
    }

OUTPUT: Ashly23
***Here we give values directly to variables.rather than this we can use set method to set the values for the objects.
class human
{
    private String name;
    private int age;

    public String getName()
    {
         return name;
    }
    public void setName(String a)               //we use void because it does not return any value.we have to passs the argument
    {
        name=a;
    }
    public  int getAge()
    {
        return age;
    }
    public void setAge(int a)                 //use void
    {
        age=a;
    }
}

public class demo {
    public static void main(String ar[])
    {
        human obj=new human();
        obj.setName("Ashly");             //Ashly is passed to variable a and is assigned to name
        obj.setAge(23);
        System.out.println(obj.getName() + obj.getAge());
        }
    }class human
{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        name = name;
    }

----GETTERS AND SETTERS 
as given above to access private variables.getName() ,setName().
while using constructor provided by the ide it gives something like this.
public void setName(String name) {
        this.name = name;       //this keyword came
    }

----THIS KEYWORD
THIS is used when the name of instance variable and paremeter are both same.This is used to resolve the ambiguity.
*The keyword is used to refer the instance variable.
class human
{
    private String name;   //instance variable name 

    public String getName() {
        return name;
    }

    public void setName(String name) {       //parameter name
        this.name = name;
    }

----CONSTRUCTOR
It looks like the method itself but we dont have to specify the data type.
*used when we have to give certain values by default to variables
*constructor name = class name
*does not return anything
*everytime an object is created it calls the constructor

class human
{
    private String name;
    private int age;
    public human()   //constructor name human
    {
        name="Ashly";
        age= 23;
    }

    public String getName()
    {
         return name;
    }
    public void setName(String a)
    {
        name=a;
    }
    public  int getAge()
    {
        return age;
    }
    public void setAge(int a)
    {
        age=a;
    }
}

public class demo {
    public static void main(String ar[])
    {
        human obj=new human();
        System.out.println(obj.getName() + obj.getAge());
        }
    }

*we can specify the assignment values in private string itself ...but its not a good practice.
*we can write database connections inside constructor

----NAMING CONVENTION
Camel case- more readable
class,interface - Start with capital letter
variables,methods - small letter
constants - full caps PI
constructor - Human()  //first letter capital becaue a class name and last round bracket because a method

---- INHERITANCE
IF WE have a class and it has so many methods.Suppose we create class calculator with basic methods(add(),substractetc).We also create another subclass for setting up more advanced features.It will coontain  all the methods in parent class and some extra features.This is called child class.
*keyword extends
*child class (sub class) and parent class(super class)
*sub class inherits parent class means it inheritts all the features of the parent class

----Single Inheritance

In single inheritance, a subclass inherits from a single superclass.
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

public class Demo {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat(); // Method inherited from Animal
        d.bark(); // Method of Dog class
    }
}


Multilevel Inheritance

In multilevel inheritance, a class is derived from a class that is already derived from another class. This forms a chain of inheritance.
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

class Puppy extends Dog {          //puppy has all the features of dog and animal
    void weep() {
        System.out.println("The puppy weeps.");
    }
}

public class Demo {
    public static void main(String[] args) {
        Puppy p = new Puppy();
        p.eat(); // Method inherited from Animal
        p.bark(); // Method inherited from Dog
        p.weep(); // Method of Puppy class
    }
}

----------------MULTIPLE INHERITANCE NOT POSSIBLE IN JAVA--------------------
EG:
class A
{
public void show()
}
class B
{
public void show()
}
class C
{
obj.show();      //if class c inheruts both A and B , there will be a confusion when the object try to call the show () method .It can use the show from either a or                    b .So in order to avoid this ambiguity , java doesnt support multiple inheritance.
}


---------THIS AND SUPER METHOD -------------

class A
{
    public A ()                         //constructor A
    {
        System.out.println("in constructor A");
    }
}
class B extends A 
{
    public B ()                       //constructor B
    {
        System.out.println("in constructor B");
    }
}
public class demo
{
    public static void main(String ar[])
    {
        B obj=new B();

    }
}                                 OUTPUT:  in constructor A
                                           in constructor B


***when we create B which inherits A  and creates the object using class B ,constructors in both child class and parent class are called.
***when we create B which inherits A and creates the object using class B, and we pass a parameter in object then parametrized constructor in  child class and         normal constructor in parent class are called.

class A
{
    public A ()
    {
        System.out.println("in constructor A");
    }
    public A (int a)         //parametrized constructor
    {
        System.out.println("in  parametrised constructor A");
    }
}
class B extends A
{
    public B ()
    {
        System.out.println("in constructor B");
    }
    public B (int b)    //parametrized constructor
    {
        System.out.println("in  parametrised constructor B");
    }
}
public class demo
{
    public static void main(String ar[])
    {
        B obj=new B(5);    //passing parameter 5

    }
}         OUTPUT:in constructor A
                 in  parametrised constructor B


The reason is SUPER

every constructor in java has a method even if we dont mention, its called super().
first statement of every constructor is super().
class A
{
    public A ()
    {
        super();
        System.out.println("in constructor A");
    }
    public A (int a)         //parametrized constructor
    {
        super();
        System.out.println("in  parametrised constructor A");
    }
}
class B extends A
{
    public B ()
    {
        super();
        System.out.println("in constructor B");
    }
    public B (int b)    //parametrized constructor
    {
        super();
        System.out.println("in  parametrised constructor B");
    }
}
public class demo
{
    public static void main(String ar[])
    {
        B obj=new B(5);

    }
}
while passing the argument to the object it goes to the parametrized constructor of B THEN FIRST IT EXECUTES SUPER()  means it goes to normal constructor of A because super() dosent have any parameter inside it,and executes it then it comes to print "in constructor B".
* if  we need to print parametrized constructor of superclass then write parameter inside super of class B.

public B (int b)    //parametrized constructor
    {
        super(b);   //FROM HERE it goes to call para constructor of A
        System.out.println("in  parametrised constructor B");
    }
}              OUTPUT:   in  parametrised constructor A
                         in  parametrised constructor B
****why using super for the parent class ,it does not inherit from any class.because by default every parent class extends from object class which is there even if not mentioned.
class A extends Object
so when calling super()of class A ,it calls the constructor of object class

----------METHOD OVERRIDING----------
Method Overriding occurs in object-oriented programming when a subclass provides a specific implementation for a method that is already defined in its parent class. The overridden method in the subclass should have the same name, return type, and parameters as the method in the parent class...
In method overloading name of method is only same parameters are different.

eg:class Calc
{
    public int add(int n1,int n2)
    {
        return n1+n2;
    }
}
class AdvCalc extends Calc
{
    public int add(int n1,int n2)
    {
        return n1+n2+1;
    }
}
public class demo
{
    public static void main (String ar[])
    {
        AdvCalc obj= new AdvCalc();
        System.out.println(obj.add(3,5));
    }
}           

OUTPUT: 9   //one add method overrides other

---------PACKAGES IN JAVA----------

Like a folder package is where we store files.
* a package can be part of another package like a folder inside a folder
* a good idea to keep our classes inside a package.
* calc and advcalc inside a package
*if we put those classes under a package then to use it the main application then we have to import it 
*if we use any inbuilt things in java it belongs to a package.so we have to import that.eg:if we use ArrayList in our program we have to import it.
  import java.utils.ArrayList;
*System.out. :- System is also inbuilt and part of a package lang. But we dont have to import it every time because it is imported by default. to import eveything in a package, we can use *.
eg:
import java.lang.System;
import java.lang.*;

------------POLYMORPHISM------------
means many behaviour.At different instances the same reference will have different behaviour.Like we have different names in our house(mother sister wife etc)..similarly we have different behaviour also.
* 2types:
---compile time polymorphism(early time polymorphism) :- if the behaviour is defined at compile time .If we know which method us executed only at compile time
                                                          eg:overloading
---run time polymorphism(late time polymorphism :-if the behaviour is defined at run time .If we know which method is executed only at run time
                                                         eg:overriding- u dont know what method is called because same name and same parameters
                                 
---------FINAL KEYWORD----------
*its like const keyword.The moment we use the final keyword the value of the variable is made const ..cannot change after that.
*final keyword can be used with a variable, method or class
--when we make a variable final --
public class demo
{
    public static void main (String ar[])
    {
         final int num=8;
         num=7;   //this throw an error because int num is set const.so cant change its value
         System.out.println(num);
    }
}

--when we make a class final --
final class Calc
{
}
class AdvCalc extends Calc //this throws an error because once the class is made final then stopping the inheritance

---when we make our method final then no one can override it ---
public  final void show()

--------TYPECASTING--------

means we are converting the datataype of a  variable from one to another forcefully .By default if we assign double value to int it is not supported.So we have to explicitly mention it.
double num =4.5;
int i= num;//this throws error. so we have to explicitly specify them.
correct:
double num =4.5;
int i=(int) num;//we will loose .5

* 
public class demo
{
    public static void main (String ar[])
    {
         A obj= new B();//upcasting
         obj.show();
    }
}

--------WRAPPER CLASS---------
Primitive datatypes int,double,float are there in java .These are not objects so we can say that java is not fuly object oriented as these primitive datatypes are not objects.So java is not 100% object oriented.100 percent means everything has to be objects but thees primitive datatypes are not.They are variable.
*There are classes for every primitive data type. 
*For int we have class Integer.
*For long we have Long.
********AUTOBOXING*********
This way of converting primitive into objects is called AUTOBOXING.

 *To convert variable int into integer object we have to write,
int data=20;
Integer i= new Integer(data);   //now i is 20 also , i is an object of integer class.This way of converting primitive into objects is called AUTOBOXING.

********UNBOXING*********
getting the value of the datatype from the object.
Integer i = new Integer(10);
datatypeValue();
int j=i.intValue();..//now j=10


---------------INTERFACES ----------------
In some situations we may have abstract class having only abstract methods and no other methods.In that case instead of creating abstract class we can create an 
Interface instead.
**Interface is not a class.
**By default all the methods inside an interface is public abstract .So no need of using that keyword.
**Interface just shows us the design but does not implement it.
**We use another class and it IMPLEMENT first class
eg: without using interface

abstract class A                                                   interface A
{                                                                  {
       public abstract void show();                    =>               void show();
       public abstract void config();                                   void config();
}                                                                  }



*********************
interface A
{
    int age= 23;   //final and static
    String name= "Ashly";

    void show();
    void config();

}
class B implements A
{
    public void show()
    {
        System.out.println("in show");
    }
    public void config()
    {
        System.out.println("in config");
    }
}

public class demo
{
    public static void main(String ar[])
    {
        A obj;
        obj=new B();
        obj.show();
        obj.config();
        System.out.println(A.age);
    }
}

OUTPUT:

in show
in config
23

*Here we create interface and we instantiate variables and methods in it.For classB we are just implementing A only not extending.B is used to define methods.SoVariable name cant be changed in B also .Therefore it is said that the variables age and name are final.T
*Variables aree final so it need to be assigned with the value inside A itself.
*Also variables are static means using the name of the object we can access the values .eg:System.out.println(A.age);

----------------ENUM-----------------
enum (short for "enumeration") is a special data type used to define a collection of constant values. Enums are used when you need a predefined set of values that a variable can take, such as days of the week, directions, or states of an object.
** we can store a list of named constants inside enum and call it when needed.
** we store them inside class as objects
**
enum Status   //Status is the class name
{
    Running,Failed,Pending,Progress        //these are named constants which are like objects of class status
}

public class demo
{
    public static void main(String ar[])
    {
        Status s = Status.Running; //similar to int i =5....type Status,reference name s,assigning object running
        System.out.println(s);
    }
}
**OUTPUT:Running
**All these objects are also numbered starting from 0 .
**Number can be seen using ordinal
**System.out.println(s.ordinal());   //gives output 0

-------------ANNOTATION------------
Annotations in Java are metadata (data about data) that provide additional information to the compiler, tools, or frameworks.Suppplement to the compiler or metadata .Sometimes to interact with complier to supply some extra data.
*@Override
Ensures that a method is overriding a method in the superclass.(ensures that the parent class methos and child class method are the same.no spelling mistake.if there is mistake it shows error.
If the method does not correctly override, the compiler throws an error.
eg:
class Parent {
    public void display() {
        System.out.println("Parent class method");
    }
}

class Child extends Parent {
    @Override
    public void display() {
        System.out.println("Child class method");
    }
}

**
@Deprecated

    Marks a method or class as deprecated, signaling that it should not be used because it may be removed in future versions.
    Tools may show warnings when this annotation is used.
@Deprecated
public void oldMethod() {
    System.out.println("This method is deprecated");
}

**
 @SuppressWarnings

    Instructs the compiler to suppress specific warnings.
    Common parameters: "unchecked", "deprecation", "rawtypes"
@SuppressWarnings("unchecked")
public void uncheckedExample() {
    List list = new ArrayList(); // Raw type warning suppressed
    list.add("Hello");
}

**

@SafeVarargs
    Suppresses unsafe warnings for a method using varargs (variable-length arguments).
**
 @FunctionalInterface

    Indicates that an interface is a functional interface (an interface with exactly one abstract method)


-------------EXCEPTIONS--------------
Types of errors
1.Compile time errors:- compiler shows it during compilation
2.run time(exceptions):-code is working.becuaes of some reasons code is not working.While opeimg a file using path and accidentaly u delete it then it shows run time error.Handling these exceptions is called exception handling
3.logical:- everything is working.output is not as expected due to errors in code.do testing inputs outputs etc.

-------------EXCEPTION HANDLING---------------
Lets loook on to statements.
*normal statements and critical statements
*
int i=0;  //normal statement
int j= 8/i; //critical statement because it depend on the value of i.If i value is 0, it throws an exception and execution stops.
execution fully stop snothing after that is printed.
** In order to handle those exceptions we have to put those statments in brackets and put it in "try"
**

public class demo
{
    public static void main(String ar[])
    {
        int i=0;
        int j=4/i;
        System.out.println(j);
        System.out.println("Bye");       //Bye is not printed as the program execution stops with division.
    }
}
OUTPUT:
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at demo.main(demo.java:7)
**in order to continue execution even with the errors we have to put it inside try {}..so the execution continues even if they encounter errors.

public class demo
{
    public static void main(String ar[])
    {
        int i=0;
        int j=0;

        try                          
        {
            j=4/i;
        }
        catch (Exception e)
        {
            System.out.println("something went wrong");
        }
        System.out.println(j);
        System.out.println("Bye");
    }
}

OUTPUT:
something went wrong
0
Bye

**When there is an error with the try block then the program throws an exception.
**Then the catch block catches that exceptioon and executes the statement something went wrong .
**Then it prints value of j(0)
** Then it prints bye
**good to put critical statments only in try block
**Catch block is executed only in case of exception
